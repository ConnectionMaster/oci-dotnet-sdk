/*
 * Copyright (c) 2020, 2025, Oracle and/or its affiliates. All rights reserved.
 * This software is dual-licensed to you under the Universal Permissive License (UPL) 1.0 as shown at https://oss.oracle.com/licenses/upl or Apache License 2.0 as shown at http://www.apache.org/licenses/LICENSE-2.0. You may choose either license.
 */

// NOTE: Code generated by OracleSDKGenerator.
// DO NOT EDIT this file manually.


using System.ComponentModel.DataAnnotations;
using System.Runtime.Serialization;
using Newtonsoft.Json;
using Newtonsoft.Json.Converters;


namespace Oci.OpsiService.Models
{
    /// <summary>
    /// MySql Sql Stats type object.
    /// </summary>
    public class MySqlSqlStats 
    {
        
        /// <value>
        /// Unique SQL ID Digest for a MySql Statement.
        /// Example: &quot;c20fcea11911be36651b7ca7bd3712d4ed9ac1134cee9c6620039e1fb13b5eff&quot;
        /// </value>
        /// <remarks>
        /// Required
        /// </remarks>
        [Required(ErrorMessage = "Digest is required.")]
        [JsonProperty(PropertyName = "digest")]
        public string Digest { get; set; }
        
        /// <value>
        /// Collection timestamp.
        /// Example: &quot;2020-03-31T00:00:00.000Z&quot;
        /// </value>
        /// <remarks>
        /// Required
        /// </remarks>
        [Required(ErrorMessage = "TimeCollected is required.")]
        [JsonProperty(PropertyName = "timeCollected")]
        public System.Nullable<System.DateTime> TimeCollected { get; set; }
        
        /// <value>
        /// Type of statement such as select, update or delete.
        /// </value>
        [JsonProperty(PropertyName = "commandType")]
        public string CommandType { get; set; }
        
        /// <value>
        /// Total number of SQL statements used in collection ranking calculation.
        /// </value>
        [JsonProperty(PropertyName = "totalRows")]
        public System.Nullable<long> TotalRows { get; set; }
        
        /// <value>
        /// Percent of SQL statements in the perf schema table relative to max or overflow count set in @@GLOBAL.performance_schema_digests_size.
        /// </value>
        [JsonProperty(PropertyName = "perfSchemaUsedPercent")]
        public System.Nullable<long> PerfSchemaUsedPercent { get; set; }
        
        /// <value>
        /// Name of Database Schema.
        /// Example: &quot;performance_schema&quot;
        /// </value>
        [JsonProperty(PropertyName = "schemaName")]
        public string SchemaName { get; set; }
        
        /// <value>
        /// The total number of times the statement has executed.
        /// </value>
        [JsonProperty(PropertyName = "execCount")]
        public System.Nullable<long> ExecCount { get; set; }
        
        /// <value>
        /// The total wait time (in picoseconds) of timed occurrences of the statement.
        /// </value>
        [JsonProperty(PropertyName = "totalLatencyInPs")]
        public System.Nullable<long> TotalLatencyInPs { get; set; }
        
        /// <value>
        /// The total time waiting (in picoseconds) for locks by timed occurrences of the statement.
        /// </value>
        [JsonProperty(PropertyName = "lockLatencyInPs")]
        public System.Nullable<long> LockLatencyInPs { get; set; }
        
        /// <value>
        /// The total number of errors produced by occurrences of the statement.
        /// </value>
        [JsonProperty(PropertyName = "errCount")]
        public System.Nullable<long> ErrCount { get; set; }
        
        /// <value>
        /// The total number of warnings produced by occurrences of the statement.
        /// </value>
        [JsonProperty(PropertyName = "warnCount")]
        public System.Nullable<long> WarnCount { get; set; }
        
        /// <value>
        /// The total number of rows affected by occurrences of the statement.
        /// </value>
        [JsonProperty(PropertyName = "rowsAffected")]
        public System.Nullable<long> RowsAffected { get; set; }
        
        /// <value>
        /// The total number of rows returned by occurrences of the statement.
        /// </value>
        [JsonProperty(PropertyName = "rowsSent")]
        public System.Nullable<long> RowsSent { get; set; }
        
        /// <value>
        /// The total number of rows read from storage engines by occurrences of the statement.
        /// </value>
        [JsonProperty(PropertyName = "rowsExamined")]
        public System.Nullable<long> RowsExamined { get; set; }
        
        /// <value>
        /// The total number of internal on-disk temporary tables created by occurrences of the statement.
        /// </value>
        [JsonProperty(PropertyName = "tmpDiskTables")]
        public System.Nullable<long> TmpDiskTables { get; set; }
        
        /// <value>
        /// The total number of internal in-memory temporary tables created by occurrences of the statement Count
        /// </value>
        [JsonProperty(PropertyName = "tmpTables")]
        public System.Nullable<long> TmpTables { get; set; }
        
        /// <value>
        /// The total number of joins that perform table scans because they do not use indexes by occurrences of the statement. If this value is not 0
        /// </value>
        [JsonProperty(PropertyName = "selectFullJoin")]
        public System.Nullable<long> SelectFullJoin { get; set; }
        
        /// <value>
        /// The total number of joins that used a range search on a reference table by occurrences of the statement
        /// </value>
        [JsonProperty(PropertyName = "selectFullRangeJoin")]
        public System.Nullable<long> SelectFullRangeJoin { get; set; }
        
        /// <value>
        /// The total number of joins that used ranges on the first table by occurrences of the statement. This is normally not a critical issue even if the value is quite large. Count
        /// </value>
        [JsonProperty(PropertyName = "selectRange")]
        public System.Nullable<long> SelectRange { get; set; }
        
        /// <value>
        /// The total number of joins without keys that check for key usage after each row by occurrences of the statement. If this is not 0
        /// </value>
        [JsonProperty(PropertyName = "selectRangeCheck")]
        public System.Nullable<long> SelectRangeCheck { get; set; }
        
        /// <value>
        /// The total number of joins that did a full scan of the first table by occurrences of the statement Count
        /// </value>
        [JsonProperty(PropertyName = "selectScan")]
        public System.Nullable<long> SelectScan { get; set; }
        
        /// <value>
        /// The total number of sort merge passes by occurrences of the statement.
        /// </value>
        [JsonProperty(PropertyName = "sortMergePasses")]
        public System.Nullable<long> SortMergePasses { get; set; }
        
        /// <value>
        /// The total number of sorts that were done using ranges by occurrences of the statement.
        /// </value>
        [JsonProperty(PropertyName = "sortRange")]
        public System.Nullable<long> SortRange { get; set; }
        
        /// <value>
        /// The total number of rows sorted by occurrences of the statement.
        /// </value>
        [JsonProperty(PropertyName = "rowsSorted")]
        public System.Nullable<long> RowsSorted { get; set; }
        
        /// <value>
        /// The total number of sorts that were done by scanning the table by occurrences of the statement.
        /// </value>
        [JsonProperty(PropertyName = "sortScan")]
        public System.Nullable<long> SortScan { get; set; }
        
        /// <value>
        /// The number of occurences of the statement which performed a table scan without using an index Count
        /// </value>
        [JsonProperty(PropertyName = "noIndexUsedCount")]
        public System.Nullable<long> NoIndexUsedCount { get; set; }
        
        /// <value>
        /// The number of occurences of the statement where the server found no good index to use Count
        /// </value>
        [JsonProperty(PropertyName = "noGoodIndexUsedCount")]
        public System.Nullable<long> NoGoodIndexUsedCount { get; set; }
        
        /// <value>
        /// The total time spent on CPU (in picoseconds) for the current thread.
        /// </value>
        [JsonProperty(PropertyName = "cpuLatencyInPs")]
        public System.Nullable<long> CpuLatencyInPs { get; set; }
        
        /// <value>
        /// The maximum amount of controlled memory (in bytes) used by the statement.
        /// </value>
        [JsonProperty(PropertyName = "maxControlledMemoryInBytes")]
        public System.Nullable<long> MaxControlledMemoryInBytes { get; set; }
        
        /// <value>
        /// The maximum amount of memory (in bytes) used by the statement.
        /// </value>
        [JsonProperty(PropertyName = "maxTotalMemoryInBytes")]
        public System.Nullable<long> MaxTotalMemoryInBytes { get; set; }
        
        /// <value>
        /// The total number of times a query was processed on the secondary engine (HEATWAVE) for occurrences of this statement Count.
        /// </value>
        [JsonProperty(PropertyName = "execCountSecondary")]
        public System.Nullable<long> ExecCountSecondary { get; set; }
        
        /// <value>
        /// The time at which statement was first seen.
        /// Example: &quot;2023-01-16 08:04:31.533577&quot;
        /// </value>
        [JsonProperty(PropertyName = "timeFirstSeen")]
        public System.Nullable<System.DateTime> TimeFirstSeen { get; set; }
        
        /// <value>
        /// The time at which statement was most recently seen for all occurrences of the statement.
        /// Example: &quot;2023-01-30 02:17:08.067961&quot;
        /// </value>
        [JsonProperty(PropertyName = "timeLastSeen")]
        public System.Nullable<System.DateTime> TimeLastSeen { get; set; }
        
    }
}
